# SHA-256 step by step

This article aims to give an introduction into the SHA-256 hash algorithm. It is accompanied by a Java-implementation (at https://github.com/f4tca7/Sha256). SHA-256 was chosen as it's one of the most commonly used (and state-of-the-art) hash functions in existance. Also, if someone understands SHA-256, understanding the other hash functions of the SHA-2 family is an easy task.

## A Hash Function
- Takes an arbitrary string as input. The input is commonly called "Message".
- Produces an output that is FIXED in length. For SHA-256 the output is always 256 bit long. The output is commonly called "Message Digest" or "Hash Value" or just "Hash". Below, hash function outputs will be called `H(x)`
- Algorithm finishes in a reasonable amount of time
- Useful to compare two messages for equality, even if we don't know the messages themselves. Meaning that we can say if ` H(x) = H(y), also message x = message y `

## Security Properties Of Hash Functions
- Hiding property (or Pre-image resistance): Just knowing `H(x)`, you cannot deduct `x`. However, this only holds up if message `x` is not chosen from a "likely" set of values. "Likely" here means that x cannot be realistically guessed by an attacker.
- Collision Free: A collision occurs if for two different messages the same hash value is calculated. "Collision free" means that it is infeasible to find two messages `x` and `y`, with `x != y`, so that `H(x) = H(y)`. Meaning it should be near impossible that two different messages result in the same hash value. Now, of course collision will always exist because the number of possible inputs (an input can be of any size) is far larger than the number of possible outputs (an output is always of a fixed length). However, (for SHA-256), you would have to compute a hash value 2^130 times to find a collision with 99.8% confidence. 
- Puzzle friendliness, especially relevant for crytocurrencies: 
  - Suppose we know two values `x` and `y`. `x` is part of the hash function input message, `y` is the hash function output. 
  - A hash function is puzzle friendly if it is infeasible to find a thrid value `k`, so that H(k | x ) = y. `k | x` means just concatenation of `k` and `x` (e.g. if `k = 1100` and `x = 0011` then `k | x = 1100 0011`). 
  - We assume `k` to be a random value from a very spread-out set of values.
  - This property is e.g. used to construct the Bitcoin proof-of-work mining puzzle. Here a miner has to iterate over `k` (`x` is given in this scenario, it is a hash of the block that's being mined), and tries to find a value `y` that is in a certain range. For bitcoin concretely, `y` needs to be smaller than a specific value deterimined every two weeks by the Bitcoin software.


## SHA-2
- SHA stands for "Secure Hash Algorithm"
- All members of the SHA-2 family share the same general approach and algorithm, but differ in sizes and constraints of inputs, outputs and working variables. For example, when working on a 32-bit architecture, it might make more sense to use SHA-256 instead of SHA-512, because SHA-256 works with 32-bit words, whereas SHA-512 works with 64-bit words.
Here is some text.

### Members of the SHA-2 family are : 

| Algorithm   | Message Size (bits) | Block Size (bits) | Word Size (bits) | Message Digest Size (bits) |
|-------------|---------------------|-------------------|------------------|----------------------------|
| SHA-224     | < 2^64              | 512               | 32               | 224                        |
| SHA-256     | < 2^64              | 512               | 32               | 256                        |
| SHA-384     | < 2^128             | 1024              | 64               | 384                        |
| SHA-512     | < 2^128             | 1024              | 64               | 512                        |
| SHA-512/224 | < 2^128             | 1024              | 64               | 224                        |
| SHA-512/256 | < 2^128             | 1024              | 64               | 256                        |
Table taken from [[1]]

## SHA-256

This section will give an introduction to the SHA-256 algorithm itself. It is mainly based on the NIST description found at 
http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf 

### High-level Overview

On a high level, SHA-256 works like this:

1. Take the input message and make sure its length (in bits) a multiple of 512 bits. This is done by adding a padding.
2. Take the passed message and parse it into `N` 512-bit blocks. 
3. Iterate over all blocks from step 2:
   1. Initialize the message schedule, a sequence of 64 32-bit words
   2. Initialize eight working variables `a ... h` with the hash values `H0 ... H7` from the previous iteration (for the first iteration, `H0 ... H7` are initialized with constants).
   3. Perform 64 iterations where working variables `a ... h` are rotated in a certain manner
   4. Compute the new intermediate hash values `H0 ... H7` as `H0 = H0 + a`, `H1 = H1 + b` and so on
4. Concatenate `H0 ... H7` as the message digest and return it.

TODO: image



### Step 1: Pad the input message

Before beginning to process the message, we have to add a padding. This is to make sure the message length (in bits) is a multiple of 512. The reason is that the algorithm will process the input message block-by-block, each block having a length of 512 bit.

Padding of the message works as follows:
- Append one bit `1` to the message
- Fill up with zeros until the message is a multiple by 512
- Construct messange length `l` as 64 bit number, and insert (not append) it to the end of the padding

Example:
- Message: "abc" = 0110 0001 0110 0010 0110 0011
- Add bit `1`: 0110 0001 0110 0010 0110 0011 1
- Add zeros so the message is a multiple of 512. In this case, the message length is 24 plus one for the bit we added. That means we have to append `512 - 1 - 24 = 487` zeros: `0110 0001 0110 0010 0110 0011 1 00 ... 487 zeros ... 00` 
- Now, insert the message length as 64-bit number. Message length is 24 decimal which is `0001 1000` binary. So our message will look like `0110 0001 0110 0010 0110 0011 1 00 ... 432 zeros... 00 00 .. 0001 1000`.
- Finally the padded message consists of:
  - The message input (24bit)
  - One bit `1`
  - 423 zero bits
  - 64 bit block with the message length
  - ... in total 512 bit

A sample Java implementation of padding a message can be found at [2] in method `private byte[] padMsg(byte[] msg)`

### Step 2: Parse the message into 512-bit blocks

Now that we have the message as multiple of 512, we need to cut it down into digestible chunks. 
This is rather straightforward, we take the message and split it into `N` 512-bit/64-byte blocks.
Each block itself is split into sixteen 32-bit words. Reason is that each of those words will be addressed during further processing.

A sample Java implementation of padding a message can be found at [2] in method `private byte [][] parseMsg(byte[] paddedMsg)`

### Step 3: Interate over `N` blocks



[1]: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf

[2]: https://github.com/f4tca7/Sha256/blob/master/src/org/toni/crypto/hashing/Sha256.java